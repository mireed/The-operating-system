5.进程等待
5.1僵尸进程
   在每个进程退出的时候，内核释放该进程所有的资源，但是仍然保留了一些信息。这些保留的信息直到进程通过调用wait/waitpid时才会释放。如果产生大量的僵尸进程，将导致系统没有可用的进程号而导致系统不能创建进程。
       如果子进程先结束而父进程后结束，即子进程结束后，父进程还在继续运行但是并未调用wait/waitpid那子进程就会成为僵尸进程；
       如果子进程后结束，即父进程先结束了，但没有调用wait/waitpid来等待子进程的结束，此时子进程还在运行，父进程已经结束。那么并不会产生僵尸进程。因为每个进程结束时，系统都会扫描当前系统中运行的所有进程，看看有没有哪个进程时刚刚结束的这个进程的子进程，如果有，就有init来接管它，成为它的父进程；
       同样的在产生僵尸进程的那种情况下，即子进程结束了但父进程还在继续运行（并未调用wait/waitpid）这段期间，假如父进程异常终止了，那么该子进程就会自动被init接管。那么它就不再是僵尸进程了。
   查看：
       top->zombie
       ps -ef -> <defunct>

5.2pid_t wait(int *status)
   使父进程阻塞
       直到一个子进程结束或者该进程接收到了一个指定的信号为止。
       如果该父进程没有子进程或者它的子进程已经结束，则wait()函数就会立即返回。
   参数status用来保存被收集进程退出时的一些状态。
   pid = wait(NULL);
      返回被收集的子进程的进程ID
      如果调用进程没有子进程，失败，返回-1
   WIFEXITED(status) ，指出子进程是否为正常退出的，如果是，它会返回一个非零值，status是指针所指向的整数
   WEXITSTATUS(status) ，当WIFEXITED返回非零值时，提取子进程的返回值。
      如果子进程调用exit(5)退出，WEXITSTATUS(status) 就会返回5；
      如果进程不是正常退出的，也就是说， WIFEXITED返回0，这个值就毫无意义。

5.3pid_t waitpid(pid_t pid,int *status,int options)
   一个非阻塞版本的 wait()功能，也能支持作业控制。
   pid:
        pid>0，等待相应子进程
        pid=-1时，等待任何一个子进程退出，同wait
        pid=0时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。
        pid<-1时，等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。
   options:
        常用0
        WNOHANG，即使没有子进程退出，它也会立即返回